对于图分布式1：
      线程5，6，8是在一个Tomcat内的运行结果，所以其结束相隔时间分别为5s，即线程睡眠时间。
对于图分布式2：
      采用两个Tomcat，Nginx作负载均衡，模拟真实分布式环境，所以其结束时间相隔10s，是因为我们看到
的是一个Tomcat内的运行结果，Nginx默认轮播请求，所以我们看到的每个线程需等待另一个Tomcat内的线
程释放掉分布式锁之后才可以获得锁正常处理业务，所以每个线程结束时间才会相差10s。
对于分布式锁的实现：
      可以利用zookeeper节点唯一性实现分布式锁，即如果创建节点成功则可以认为自己获得了锁，进行业务
处理后删除此节点，如果创建失败，则可以监听此节点，等待节点被删除。业务处理结束后，删除节点后，这
时其他线程得到watch事件，可以再次创建节点/lock/xxx，成功则代表再次获得这个锁。
       这种算法比较简单，一旦节点被删除所有线程都会去争相创建节点，性能较差。可以利用zookeeper类似
领导选举那样的算法实现分布式锁，谁是领导节点谁就获得了锁，删除自己创建的节点即表示释放锁。